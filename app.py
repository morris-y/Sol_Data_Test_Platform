from flask import Flask, render_template, request, jsonify
import subprocess
import os
from datetime import datetime, timedelta

app = Flask(__name__)

# Default token address if none is provided
DEFAULT_TOKEN_ADDRESS = "6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN"  # Trump Token

# 添加basename过滤器，用于从完整路径中提取文件名
@app.template_filter('basename')
def basename_filter(path):
    return os.path.basename(path) if path else ""

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate', methods=['POST'])
def generate():
    # Get the token address from the form
    token_address = request.form.get('token_address', DEFAULT_TOKEN_ADDRESS)
    if not token_address:
        token_address = DEFAULT_TOKEN_ADDRESS
        
    script_path = os.path.join(os.path.dirname(__file__), 'random_time_generator.py')
    try:
        result = subprocess.run(['python', script_path], capture_output=True, text=True, check=True, encoding='utf-8')
    except subprocess.CalledProcessError as e:
        return f"Error running script: {e}\nOutput: {e.stdout}\nError: {e.stderr}", 500
    except FileNotFoundError:
         return "Error: random_time_generator.py not found.", 500

    intervals = result.stdout.strip().splitlines()
    parsed_intervals = []
    for line in intervals:
        try:
             if "Start:" in line and "End:" in line:
                 parts = line.split(', ')
                 start_part = parts[0].split('Start: ')[1]
                 end_part = parts[1].split('End: ')[1]
                 parsed_intervals.append({"start": start_part, "end": end_part})
        except IndexError:
             print(f"Warning: Could not parse line: {line}")
             continue

    if not parsed_intervals:
        return "Error: No valid intervals generated by the script.", 500

    single_interval = [parsed_intervals[0]] if parsed_intervals else []

    return render_template('index.html', intervals=single_interval, token_address=token_address)


def convert_time_to_utc(time_str):
    """Convert time from GMT+8 to UTC (GMT+0)"""
    # Parse the input time string in GMT+8
    dt = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S')
    
    # Convert from GMT+8 to UTC (subtract 8 hours)
    utc_dt = dt - timedelta(hours=8)
    
    # Format the UTC time back to string
    return utc_dt.strftime('%Y-%m-%d %H:%M:%S')


def create_birdeye_script(start_time, end_time, token_address=DEFAULT_TOKEN_ADDRESS):
    """Create a Python script to fetch Birdeye API data for the given time range."""
    # Prepare directory
    birdeye_dir = 'QA-20250411/Birdeye'
    output_dir = f'{birdeye_dir}/output_py'
    os.makedirs(output_dir, exist_ok=True)
    
    # Generate timestamp for the script filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    script_filename = f'birdeye_fetch_{timestamp}.py'
    script_path = os.path.join(output_dir, script_filename)
    
    # 读取模板文件并替换占位符
    with open(os.path.join(os.path.dirname(__file__), 'QA-20250411', 'Birdeye', 'birdeye_fetcher_template.py'), 'r') as template_file:
        script_content = template_file.read()
    
    # 替换占位符
    script_content = script_content.replace("__START_TIME__", start_time)
    script_content = script_content.replace("__END_TIME__", end_time)
    script_content = script_content.replace("__TOKEN_ADDRESS__", token_address)
    
    # Write the script to file
    with open(script_path, 'w') as file:
        file.write(script_content)
    
    return script_path


@app.route('/confirm', methods=['POST'])
def confirm():
    start_time = request.form.get('start_time')
    end_time = request.form.get('end_time')
    token_address = request.form.get('token_address', DEFAULT_TOKEN_ADDRESS)
    
    # Use default if token is not provided
    if not token_address:
        token_address = DEFAULT_TOKEN_ADDRESS

    if not start_time or not end_time:
        return "Error: Missing time interval.", 400

    selected_interval_display = f"Start: {start_time}, End: {end_time}"

    # Extract the actual timestamp values without 'Start: ' and 'End: ' prefixes
    start_time_value = start_time.split('Start: ')[1] if 'Start: ' in start_time else start_time
    end_time_value = end_time.split('End: ')[1] if 'End: ' in end_time else end_time

    sql_templates = {
        '1h': f"""SELECT * FROM 
    hubble.old_dex_ohlcv_hour
WHERE 
    token = '{token_address}'
    AND time BETWEEN '{start_time_value}' AND '{end_time_value}'
ORDER BY time DESC
LIMIT 1000;""",
        '1m': f"""SELECT * FROM 
    hubble.old_dex_ohlcv_min
WHERE 
    token = '{token_address}'
    AND time BETWEEN '{start_time_value}' AND '{end_time_value}'
ORDER BY time DESC
LIMIT 1000;"""
        # Removed 1s template as Birdeye does not support it
    }

    # Ensure the target directory exists
    sql_path = os.path.join(os.path.dirname(__file__), 'QA-20250411', 'DBeaver SQL', 'output_sql')
    try:
        os.makedirs(sql_path, exist_ok=True)
    except Exception as e:
        return f"Error creating output directory {sql_path}: {e}", 500

    # List to store paths of generated files
    generated_files = []

    for suffix, sql_template in sql_templates.items():
        sql_content = sql_template.format(start_time=start_time_value, end_time=end_time_value)
        file_path = os.path.join(sql_path, f'query_{suffix}.sql')
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            generated_files.append(file_path)
        except Exception as e:
            return f"Error writing to file {file_path}: {e}", 500
    
    # Get the epoch times for SQL
    start_epoch = int(datetime.strptime(start_time_value, '%Y-%m-%d %H:%M:%S').timestamp())
    end_epoch = int(datetime.strptime(end_time_value, '%Y-%m-%d %H:%M:%S').timestamp())
    
    # Generate Birdeye fetcher script
    script_dir = os.path.join(os.path.dirname(__file__), 'QA-20250411', 'Birdeye', 'output_py')
    birdeye_script_path = create_birdeye_script(start_time_value, end_time_value, token_address)
    
    # Prepare UTC interval display
    utc_start = convert_time_to_utc(start_time_value)
    utc_end = convert_time_to_utc(end_time_value)
    utc_interval_display = f"Start: {utc_start}, End: {utc_end}"
    
    return render_template('confirmation.html', 
                          interval=selected_interval_display,
                          sql_paths=generated_files,
                          birdeye_script_path=birdeye_script_path,
                          utc_interval=utc_interval_display,
                          utc_start_time=utc_start,
                          utc_end_time=utc_end,
                          token_address=token_address)


@app.route('/run_birdeye_fetcher', methods=['POST'])
def run_birdeye_fetcher():
    # Get the birdeye fetcher script details from the form
    script_filename = request.form.get('script_filename')
    script_path = os.path.join(os.getcwd(), 'QA-20250411', 'Birdeye', 'output_py', script_filename)
    
    # Get time parameters from the form
    start_time = request.form.get('start_time')
    end_time = request.form.get('end_time')
    token_address = request.form.get('token_address')
    
    # Instead of running the generated Python script, directly run birdeye_fetcher.py
    birdeye_dir = os.path.join(os.getcwd(), 'QA-20250411', 'Birdeye')
    fetcher_script = os.path.join(birdeye_dir, "birdeye_fetcher.py")
    
    # Build the command to run
    cmd = ["python", fetcher_script, start_time, end_time]
    if token_address and token_address.strip():
        cmd.extend(["--token", token_address])
    
    # Run the command directly in a new terminal window
    if os.name == 'nt':  # Windows
        # Use start cmd /k to open in a new window and keep it open
        cmd_str = f'start cmd /k "cd /d {birdeye_dir} && python birdeye_fetcher.py "{start_time}" "{end_time}" --token {token_address}"'
        subprocess.Popen(cmd_str, shell=True)
    else:  # Mac/Linux
        terminal_cmd = f'cd "{birdeye_dir}" && python birdeye_fetcher.py "{start_time}" "{end_time}" --token "{token_address}"'
        subprocess.Popen(['gnome-terminal', '--', 'bash', '-c', f'{terminal_cmd}; exec bash'])
    
    # Render the success template
    return render_template('success.html', 
                          message=f"Launched Birdeye data fetcher in a new terminal window.<br>Start time: {start_time}<br>End time: {end_time}<br>Token address: {token_address}")


@app.route('/run_birdeye', methods=['POST'])
def run_birdeye():
    script_path = request.form.get('script_path')
    
    if not script_path or not os.path.exists(script_path):
        return "Error: Invalid script path.", 400
    
    try:
        # Run the birdeye fetcher script
        result = subprocess.run(['python', script_path], 
                               capture_output=True, 
                               text=True,
                               check=True)
        
        # Build the result message
        output_message = f"""
<h1>Birdeye Fetcher Execution Results</h1>
<h2>Command Output:</h2>
<pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto;">
{result.stdout}
</pre>
"""
        if result.stderr:
            output_message += f"""
<h2>Errors/Warnings:</h2>
<pre style="background-color: #fff0f0; padding: 10px; border-radius: 5px; overflow-x: auto;">
{result.stderr}
</pre>
"""
        
        output_message += """
<div style="margin-top: 20px;">
    <a href="/" style="display: inline-block; padding: 10px 15px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px;">Return to Home</a>
</div>
"""
        
        return output_message
        
    except subprocess.CalledProcessError as e:
        error_message = f"""
<h1>Error Running Birdeye Fetcher</h1>
<p>An error occurred while executing the Birdeye fetcher script.</p>
<h2>Command Output:</h2>
<pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto;">
{e.stdout}
</pre>
<h2>Error:</h2>
<pre style="background-color: #fff0f0; padding: 10px; border-radius: 5px; overflow-x: auto;">
{e.stderr}
</pre>
<div style="margin-top: 20px;">
    <a href="/" style="display: inline-block; padding: 10px 15px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px;">Return to Home</a>
</div>
"""
        return error_message, 500
    except Exception as e:
        return f"An unexpected error occurred: {e}", 500


if __name__ == '__main__':
    if not os.path.exists(os.path.join(os.path.dirname(__file__), 'templates')):
        print("Error: 'templates' directory not found next to app.py")
    app.run(debug=True, host='0.0.0.0', port=5000)
